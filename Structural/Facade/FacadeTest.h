#pragma once

/*Шаблон Facade — предоставляет упрощенный и унифицированный интерфейс для набора интерфейсов или подсистем в рамках более крупной системы,
что упрощает ее использование и снижает сложность системы для клиентов.
По сути, он действует как фасад или точка входа в более сложную систему, защищая клиентов от ее тонкостей.

   (композирует в себе "Подсистемы"  -- вызывает их в "понятных клиенту терминах" )
*/
#include "CarFacade.h"
class FacadeTest {
public: static void test()
	{
        // Using the Facade to start and stop the car
        Car car;
        car.StartCar();
        // Simulate some driving
        car.StopCar();
	}
};

/*
* Составные части паттерна: 
Client представляет собой класс или компонент, использующий шаблон фасада.
Класс Facade — это класс, реализующий шаблон Facade. Он предоставляет упрощенный интерфейс клиенту и делегирует вызовы базовым подсистемам.
Subsystem 1 и Subsystem 2...4 5 — это компоненты или классы, которые выполняют определенные операции. Клиент взаимодействует с этими подсистемами через фасад.*/


/*
Преимущества шаблона «Фасад» в шаблоне проектирования C++
Вот преимущества использования шаблона «Фасад» в C++:

Упрощенный интерфейс : Шаблон фасада обеспечивает простой и понятный интерфейс для сложной системы.
Он скрывает сложные детали подсистем и представляет унифицированный набор методов, что упрощает взаимодействие клиентов с системой.

Абстракция сложности : абстрагируется от сложности базовых подсистем. Клиентам не нужно знать, как работают вместе различные компоненты или классы; 
они могут достичь своих целей, вызывая методы на фасадном объекте.

Уменьшенная связанность : Внедряя фасад, зависимости между клиентским кодом и подсистемами сводятся к минимуму.
Эта слабая связанность повышает удобство обслуживания и позволяет вносить изменения в подсистемы, не затрагивая клиентский код.

Улучшенная читаемость кода : Шаблон Facade улучшает читаемость кода, предоставляя понятный и лаконичный API. 
Он упрощает клиентский код, делая его более понятным и менее подверженным ошибкам.

Продвигает модульную разработку : поощряет модульный подход к проектированию программного обеспечения. 
Каждая подсистема может разрабатываться, тестироваться и поддерживаться независимо. 
Эта модульность упрощает разработку и поддержку.

Инкапсуляция изменений : если требуются изменения в подсистемах 
(например, обновление библиотеки или рефакторинг внутреннего кода), фасад действует как буфер. 
Вы можете вносить изменения в подсистемы, сохраняя при этом интерфейс фасада стабильным, минимизируя влияние на клиентов.

Улучшенная возможность повторного использования : фасады можно повторно использовать в разных частях кодовой базы или в разных проектах,
обеспечивая последовательный и стандартизированный способ взаимодействия с базовой системой.

Улучшенная отладка : отладка более управляема, поскольку проблемы, связанные с подсистемами,
могут быть локализованы внутри фасада. Такая изоляция упрощает процесс отладки
и снижает сложность поиска и исправления ошибок.

Продвигает лучшие практики : поощряет использование принципов проектирования, таких как разделение интерфейсов и принцип единой ответственности.
Каждая подсистема фокусируется на определенной задаче, что приводит к более организованной и поддерживаемой кодовой базе.



Недостатки шаблона «Фасад» в шаблоне проектирования C++
Вот некоторые из потенциальных недостатков и ограничений использования шаблона «Фасад» в C++:

Ограниченная гибкость : Шаблон фасада может чрезмерно упрощать интерфейс подсистем, 
что может ограничить гибкость продвинутых пользователей, которым требуется детальный контроль над подсистемами.
Продвинутые пользователи могут посчитать интерфейс фасада слишком ограничительным.

Повышенная сложность: в некоторых случаях сам фасад может стать сложным, если ему необходимо поддерживать широкий спектр функций. 
Эта сложность внутри фасада может быть сложной для управления и обслуживания.

Расходы на обслуживание : Хотя шаблон фасада может защитить клиентов от изменений в подсистемах, он также может привести к расходам на обслуживание.
Если подсистемы часто меняются или если подсистем много, поддержание фасада в актуальном состоянии с учетом этих изменений может быть трудоемким.

Накладные расходы на производительность : использование фасада может привести к небольшим накладным расходам на производительность 
из-за дополнительных вызовов методов и абстракций. В приложениях, критических к производительности, эти накладные расходы могут стать проблемой.

Возможное нарушение принципа открытости-закрытости : Шаблон фасада может привести к нарушению принципа открытости-закрытости,
если добавление новых функций или подсистем требует изменения класса фасада. 
Это может произойти, если фасад необходимо расширить для внесения изменений в базовую систему.

Дублирование функциональности : Если для разных клиентов или разных вариантов использования создается несколько фасадов,
может возникнуть дублирование функциональности в этих фасадах. Э
то может привести к избыточности кода и проблемам обслуживания.

Сложная инициализация: если подсистемы требуют сложной инициализации или настройки, 
фасаду может потребоваться раскрыть эту сложность клиенту,
что сделает процесс инициализации менее простым.

Размер и сложность фасада : Если подсистемы очень многочисленны и сложны, сам фасад может стать большим и сложным. 
Это может сделать фасад более сложным для понимания и обслуживания.

Тесная связь с подсистемами: в некоторых случаях фасад может стать тесно связанным с инкапсулированными им подсистемами. 
Это может произойти, если фасаду необходимо получить доступ к внутренним деталям подсистем для выполнения своих задач, что противоречит цели слабой связи.

Не всегда подходит: Шаблон фасада подходит не для всех сценариев. Он наиболее полезен при работе со сложными системами,
где требуется упрощение интерфейса. 
      --------------Для простых систем добавление фасада может привести к ненужной сложности.
*/