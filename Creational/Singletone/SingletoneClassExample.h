#pragma once
#include <iostream>
// Singletone - это шаблон проектирования, который гарантирует, 
// что во всей программе может существовать только один экземпляр класса.
// 
// Это означает, что если вы попытаетесь создать другой экземпляр класса,
//  он вернет тот же экземпляр, который был создан ранее.
class Singleton {
    // Private static instance variable
    static Singleton* instance;

public:
    // Static method вернет указатель на единственный объект класса Singleton
    static Singleton& getInstance()
    {
        // If the instance doesn't exist, create it
        if (!instance) {
            instance = new Singleton();
        }
        return *instance;
    }

    // Public method to perform some operation
    void someOperation()
    {
        std::cout << "Singleton is performing some operation." << std::endl;
    }

    // Удаляем конструктор копирования
    Singleton(const Singleton&) = delete;

    //удаляем оператор присваивания
    Singleton& operator=(const Singleton&) = delete; 

private:
    // Констрктор Private --- чтоб никто им нес мог воспользоваться --- кроме static Singleton& getInstance()
    Singleton()
    {
        std::cout << "Singleton instance created."
            << std::endl;
    }

    // Приватный destructor  чтобы недопустить удаление во внешнем коде
    ~Singleton()
    {
        std::cout << "Singleton instance destroyed."
            << std::endl;
    }
};

// устанавливаем the static instance to nullptr
Singleton* Singleton::instance = nullptr;


/*Ключевые компоненты:
1 Singletone class: Это класс, который вы хотите сделать одноэлементным. 
У него есть приватный конструктор, приватный деструктор и приватный статическая переменная-член для хранения единственного экземпляра класса.

2 Статическая переменная-член: Это закрытая статическая переменная-член внутри одноэлементного класса, которая содержит единственный экземпляр класса. 
Обычно он инициализируется nullptr или экземпляром самого класса.

3 Статический метод (getInstance): Public static метод в одноэлементном классе, называемый getInstance.
Этот метод отвечает за создание экземпляра, если он не существует, или за возврат существующего экземпляра, если он существует.
Он гарантирует, что существует только один экземпляр класса.

4 Удалить конструктор копирования и оператор присваивания: Чтобы предотвратить копирование экземпляра Singleton, конструктор копирования и оператор присваивания должны быть удалены в классе Singleton.*/

/*
Преимущества одноэлементного шаблона в шаблонах проектирования C ++
Вот преимущества одноэлементного шаблона в C ++:

    Единый экземпляр: Основное преимущество одноэлементного шаблона заключается в том,
    что он гарантирует наличие только одного экземпляра класса во всем приложении. 
    Это особенно полезно, когда вы хотите контролировать доступ к ресурсу или обеспечить единую точку управления для определенной функциональности.

    Глобальный доступ: Экземпляр Singleton доступен глобально во всем приложении. 
    Это позволяет разным частям вашего кода получать доступ к одному и тому же экземпляру и манипулировать им,
    что делает его удобным для совместного использования данных или функциональности.

    Отложенная инициализация: В одноэлементном шаблоне часто используется отложенная инициализация, что означает, что экземпляр создается только при первой необходимости. Это может увеличить время запуска приложения и эффективность использования памяти, поскольку ресурсы выделяются только при необходимости.
    Управление ресурсами: Синглтоны можно использовать для управления общими ресурсами, такими как подключения к базе данных, пулы потоков, параметры конфигурации или механизмы кэширования. Контролируя доступ к этим ресурсам с помощью одноэлементного шаблона, вы можете обеспечить эффективное распределение и освобождение ресурсов.
    Уменьшенное использование памяти: поскольку существует только один экземпляр одноэлементного класса, это сокращает использование памяти по сравнению с созданием нескольких экземпляров одного и того же класса.
    Позволяет избежать глобальных переменных: Singleton предоставляет контролируемый способ получения глобального доступа, не прибегая к глобальным переменным, которые могут быть подвержены ошибкам и сложными в управлении.
    Потокобезопасность: Одноэлементные шаблоны могут быть реализованы для обеспечения потокобезопасности, гарантируя безопасный доступ к единственному экземпляру в многопоточных средах.
    Упрощение тестирования: Одноэлементные экземпляры можно легко заменить макетными объектами или тестовыми двойниками во время модульного тестирования, что упрощает изоляцию и тестирование определенных частей вашего кода.
    Согласованное состояние: Поскольку существует только один экземпляр, это гарантирует, что состояние синглтона остается согласованным на протяжении всего жизненного цикла приложения.
    Улучшенная организация кода: Singleton помогает упорядочить ваш код, предоставляя четкую точку доступа к определенной функциональности или ресурсу. Он обеспечивает структурированный способ взаимодействия с этой функциональностью, делая кодовую базу более удобной в обслуживании.
    Управление инициализацией: Singleton позволяет вам контролировать, когда и как инициализируется экземпляр, позволяя вам выполнить любую необходимую настройку перед использованием экземпляра.
    Недостатки одноэлементного шаблона в шаблонах проектирования C ++




Вот некоторые недостатки использования одноэлементного шаблона в C ++:

    Глобальное состояние: Одним из основных недостатков одноэлементного шаблона является то,
    что он вводит в ваше приложение форму глобального состояния. Это означает, что экземпляр Singleton доступен из любого места в коде,
    что может привести к скрытым зависимостям и затруднить отслеживание потока данных и их анализ.

    Тесная связь: Одноэлементный шаблон может создавать тесную связь между различными частями вашей кодовой базы,
    поскольку многие части приложения могут полагаться на одноэлементный экземпляр. 
    Это может затруднить изменение или замену одноэлементного класса без ущерба для других компонентов.

    Проблемы тестирования: Тестирование может быть более сложным с одноэлементными классами.
    Поскольку экземпляр Singleton доступен по всему миру, изолировать и тестировать отдельные компоненты изолированно может быть непросто.
    Модульные тесты могут зависеть от состояния синглтона, что делает тесты менее предсказуемыми.

    Ограниченное наследование: наследование с помощью одноэлементного класса может быть проблематичным.
    Если вы хотите получить подкласс из Singleton , это может работать не так, как ожидалось, 
    потому что шаблон Singleton применяет один экземпляр базового класса. Создание подклассов может привести к неожиданному поведению или нарушить принцип единственного экземпляра.
    Сложно смоделировать: При тестировании может быть сложно смоделировать одноэлементный экземпляр или заменить его тестовым double. Одноэлементный шаблон жестко привязывает ваш код к определенному экземпляру, делая его менее гибким для целей тестирования.
    Проблемы с параллелизмом: При неправильной реализации одноэлементные шаблоны могут создавать проблемы с параллелизмом в многопоточных приложениях. Возможно, вам потребуется использовать механизмы синхронизации, такие как блокировки или мьютексы, для обеспечения безопасного доступа к экземпляру Singleton, что может усложнить ваш код.
    Чрезмерное использование одноэлементного шаблона: Из-за его удобства разработчики могут злоупотреблять одноэлементным шаблоном, что приводит к обилию одноэлементных экземпляров в приложении. Это может нарушить назначение шаблона и привести к увеличению использования памяти.
    Накладные расходы на инициализацию: Отложенная инициализация, хотя и часто является преимуществом, может привести к некоторым накладным расходам при первом обращении к экземпляру Singleton. Если процесс инициализации ресурсоемкий, это может повлиять на время запуска приложения.
    Трудности при отладке: Отладка кодовой базы на основе одноэлементного кода может быть сложной задачей, особенно когда возникают проблемы, связанные с состоянием синглтона. Может быть сложно отследить источник проблем, когда несколько частей кода могли изменять данные синглтона.
    Ограниченное внедрение зависимостей: Использование внедрения зависимостей и инверсии управления становится менее простым при использовании одноэлементных экземпляров. Внедрение альтернативных реализаций или конфигураций может оказаться сложной задачей, поскольку доступ к экземпляру Singleton обычно осуществляется глобально.*/